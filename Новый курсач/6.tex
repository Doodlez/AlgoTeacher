\newpage
\thispagestyle{plain}

\section{Теория обучающих программ}
\subsection{Общие сведения}
Как уже говорилось ранее, степень важности обучающих систем в процессе нашей жизнедеятельности постоянно растёт, и в последние годы на рынке программного продукта стало появляться всё больше обучающих систем, охватывающие различные сферы нашей деятельности. Большое внимание здесь уделяется автоматизированным обучающим системам (АОС), о которых речь пойдет дальше.

Программа имеет право называться системой только в том случае, если она представляет собой набор взаимосвязанных компонентов, каждый из которых выполняет свои конкретные функции. Также необходимым фактором является присутствие в программе компоненты интерфейса пользователя, которая играет немаловажную роль для обратной связи с обучаемым, и компоненты, ответственной за реализацию необходимой логики решения задач. 

Ниже, на рис.1, приведена классификация структурного построения АОС.

\begin{center}
\includegraphics[width=13cm]{structure.png}

Рисунок $1$ --- Классификация АОС.
\end{center}

Как мы видим, все системы делятся на два больших типа - разомкнутые и замкнутые. К разомкнутым относятся системы, в которых не учитывается обратная реакция пользователя. Примером презентационной системы может служить, например, набор слайдов, дающий информацию о каком-нибудь языке программирования. В тестирующей системе, как несложно догадаться по названию, фигурирют тесты, которые пользователь проходит для проверки своих знаний по соответствующему разделу того или иного предмета. Теперь остановимся поподробнее на замкнутых системах.

Главным достоинством этого типа систем является обратная связь с обучаемым, т.е. на любое действие пользователя происходит конкретное действие системы, и эти действия непосредственным образом зависят от действий пользователя. Здесь также выделяется две основных основных разновидности таких систем --- имитационные и тестирующие-обучающие.

Главным инструментом имитационных систем является моделирование реальной ситуации в той или иной сфере предметной области. В пример можно привести различные имитаторы и игровые тренажеры. В частности, имитационная программа компании Maxis позволяет имитировать развитие и управление городом. Здесь имитируются различные ситуации, начиная от размещения промышленных предприятий и транспортных сетей и заканчивая моделированием экстремальных ситуаций и путей их ликвидации ( подробнее см. в источнике $[2]$).

Основыми задачами тестирующих-обучающих систем являются передача обучаемому необходимых знаний в изучаемой области и постоянный контроль полученных знаний, т.е. обеспечение обучаемого различными тестами, с помощью которых можно выявить уровень усовяемости изученного материала. Именно от результатов этих тестов и зависит дальнейшее поведение системы, а именно --- если ученик успешно сдал тест по пройденной теме, то можно переходить к следующей, если таковая имеется, иначе нужно предпринимать другие действия, например, такое действие как повторное обучение по данной теме.

Примеры обучающих систем можно посмотреть по следующим ссылкам: обучение английскому языку $[3]$ и обучению алгебре $[4]$

Основная рекомендации по разработке обучающих программ взяты из электронных ресурсов: $[5]$ и $[7]$ 

Обучающая система, написание которой ведется в рамках данной дипломной работы, относится как раз к тестирующим-обучающим системам.

\section{Технологии пакета обучающих программ}
Платформа .Net обладает большим инструментарием по работе с объектно-ориентированными программами, далее будет разобраны основные используемые технологии. Подробная информация в источнике $[6]$.
	\subsection{Классы, члены класса и экземпляры}
	Классы --- это основа объектно-ориентированного программирования. Класс представляет собой инкапсуляцию данных и методов для их обработки. В данной обучающей программе наиболее интересным является класс для инкапсуляции данных и методов конкретных модулей, благодаря чему, можно работать со всеми модулями в общем виде используя экземпляры класса. Каждый экземпляр будет предоставлять доступ к конкретному модулю посредством членов самого класса. В C\# имеются следующие члены классов:
	\begin{itemize}
	\item поле --- член-переменная, которая содержит некоторое значение;
	\item метод --- реальный код, воздействующий на данные объекта;
	\item свойства --- поля, которые, по сути, являются методами, так называемые smart fields;
	\item константы --- поле, значение которого нельзя изменить;
	\item индексаторы - позволяют индексировать экземпляры класса или структур так же, как массивы. Напоминают свойства (так же используют аксессоры для доступа к данным), но их методы доступа принимают параметры;
	\item события --- вызывает исполнение некоторого фрагмента кода. Подробнее про события см. ниже.
	\end{itemize}	
		Как уже говорилось выше, обучающая программа содержит класс описывающий данные и методы модулей (обучение конкретному алгоритму). Создавая экземпляры данного класса и устанавливая нужные поля и свойства, можно использовать общий метод для всех модулей. 
		Рассмотрим пример. Имеется класс
	
		\begin{lstlisting}[label=some-code,caption= Пример класса]
		public Task{
			private someDataType data;
			Task(someDataType Data){ 
				this.data = Data;
			}
			
			public void Execute(){ 
			/* ...необходимый код использущий наши данные... */ 
			}
		}
		\end{lstlisting}
		
		Как видим, в классе есть поле с приватными данными, устанавливаемыми при создании экземпляра, и есть метод Execute() который будет использовать данные. Создаём набор экземпляров класса MyTask соответствующий нескольких задачам. Добавляем набор в какую-нибудь коллекцию. Теперь, взяв любой элемент из коллекции можно выполнить метод Execute(). В разрабатываемой обучающей программе набор классов модулей передаётся в элемент управления DropBox. При нажатии на кнопку на форме берётся выбранный экземпляр класса и выполняется  метод отображения первого диалогового окна. Данный подход очень удобный и облегчает программирование, делая программу структурированной. \\
		
		Ещё одна особенность, связанная с классами в разрабатываемой обучающей программе, это создание объектов внутри класса, вместо передачи уже созданных объектов. В данном случае, не используемые объекты не создаются раньше времени и не занимают ресурсы (время, память). Например, вместо того, чтобы хранить в экземпляре класса экземпляр формы, можно только указать тип формы (который может отличаться от экземпляра к экземпляру) и создавать её в каком-нибудь методе. Для этого, тип формы хранится в поле тип Type, а в самом методе вызывается Activator.CreateInstance(formType).
	
	\subsection{Интерфейсы}
		Интерфейсы в C\# предоставляют высокую степень абстракции. Можно определить основные члены и реализовывать разные классы на основе интерфейса. Тогда, можно использовать объекты, ничего не зная об их конкретном устройстве, используя члены интерфейса. \\
		
		Рассмотрим конкретный пример из разрабатываемой обучающей программы. \\
		
		\begin{lstlisting}[label=some-code,caption= Пример интерфейса]	
		public interface IQuest
		{
        string Name { get;}
        string Question { get;}
        string Answer { get;}
        Boolean CheckAnswer(string answer);
		}
		\end{lstlisting}
		
		Как видим, интерфейс простой, описывает задания для пользователя. Конкретная реализаций CheckAnswer позволит проверять любой вид вопросов (да-нет, выбор из множества, открытый вопрос и т.д.). Можно просто вызывать метод CheckAnswer, не думая, для какого типа вопросов нужно проверить ответ.
		
	\subsection{Формы и элементы управления}
	
		Немного поговорим о формах и элементах управления. .Net обладает огромным набором всевозможных элементов управления для графических приложений, это кнопки, меню, выпадающие списки и т.п. Но иногда, стандартных элементов управления не хватает, либо необходимо как-то модифицировать стандартные элементы управления. Тогда можно создать пользовательский элемент управления (user control), который может состоять из стандартных элементов, либо наследоваться от существующего элемента управления с целью расширения возможностей. 
		Также, использование собственных контролов позволяет вынести с нескольких форм общие группы элементов, написать соответствующие обработчики и использовать. Так программа становится компактнее, код перестаёт дублироваться и настроенный компонент можно использовать в любом месте вашего приложения. 
		Хорошей практикой создания собственных контролов является вынесение их в отдельный проект. Тогда контролы можно будет использовать, где захотите.
		В разрабатываемой программе отдельно вынесены контролы для ввода ответа на вопросы. В форме с вопросом, нужный контрол программно встраивается в нужном месте.  
		
	\subsection{События}
	
		События позволяют вызывать исполнения некоторого фрагмента кода. События позволяют организовать взаимодействие с пользователем: пользователь нажал кнопку --- возникло соответствующее событие, пользователь двинул мышку --- возникло новое событие. События также могут возникнуть и в результате работы программы. Можно описать собственное событие и соответствующий делегат обработчик и использовать их в программе, для вызова и обработки события. 
		Рассмотрим на примеры обучающей программы. 
		
		\begin{lstlisting}[label=some-code,caption= Пример событий]	
	public class QuestEvents
	{
        public delegate void QuestEventHandler(object sender, QuestEventArgs e);

        public class QuestEventArgs : EventArgs
        {
            public IQuest Quest
            {
                get;
                private set;
            }
            public Coordinate Coord
            {
                get;
                private set;
            }
            public QuestEventArgs(IQuest quest, Coordinate coord)
            {
                this.Quest = quest;
                this.Coord = coord;
            }
        }
	}
	\end{lstlisting}
	
	Представленный выше класс нужен для генерации и обработки события. Событие должно возникать, когда программа собирается задать пользователю вопрос. 
	
	Реализовав обработчик события и вызвав событие в процессе работы алгоритма позволит задать пользователю вопрос, проверить ответ и в случае успеха продолжить выполнение алгоритма. 

	\subsection{Многопоточность}
	
	Но напрямую, просто вызвав событие, поставить программу на паузу не получится, так как нужно дождаться ответа пользователя, прежде чем переходить к следующему шагу алгоритма. Возникает проблема: с одной стороны у нас пользовательский интерфейс, на котором отображается вопрос и принимается ответ, с другой стороны реализация какого-нибудь алгоритма. Мы встретили две задачи которые нужно выполнять отдельно друг от друга, при этом периодически одна задача будет ждать другую.
	Для решения такой проблемы можно использовать несколько потоков. Пользовательский интерфейс выполняется стандартным потоком, а для алгоритма мы создаём ещё один, выполнением которого можно легко управлять. \\
	
	Потоки в C\# представлены объектом Thread, подробнее о котором можете почитать в руководстве на сайте mdsn.com. 
	Создав поток для алгоритма, мы может генерировать в нём событие, которое будет перехватывать основной поток. На это время, выполнение алгоритма приостанавливается, а на форме появляется вопрос. Вычисления продолжатся после ввода значения. \\
	
	Ожидание ввода можно сделать при помощи следующей конструкции:
	
	\begin{lstlisting}[label=some-code,caption= Пример ожидания]	
	while (!pressed)
    {
                System.Threading.Thread.Sleep(100);
    }
	\end{lstlisting}
	Где $pressed = false$, пока не будет введён ответ.
	
	Но, при использовании нескольких потоков может возникнуть проблема обращения потока к объекту, созданному в другом потоке (например, элементы управления). Но выход есть, необходимо использовать InvokeRequired и Invode (подробнее см. официальной документации):
		\begin{lstlisting}[label=some-code,caption= Пример решения проблемы с потоками]	
		public delegate void SetQuestionCallback(string text);
		
		// функция для установки вопроса из др. потока
        public void SetQuestionText(string text)
        {
                if (QuestionLabel.InvokeRequired)
                {
                    SetQuestionCallback deleg = new SetQuestionCallback(SetQuestionText);
                    this.Invoke(deleg, new object[] { text });
                }
                else
                {
                    QuestionLabel.Text = text;
                }
        }
		\end{lstlisting}
		
		QuestionLabel.InvokeRequired проверяет, из того ли потока происходит обращение, и если не из того, то указывает какой поток должен исполнять метод.

\section{Пакет Прикладных Программ "AlgoTeacher"}
	\subsection{Общая структура}
	В общем виде наш пакет состоит из следующих основных компонентов:
	\begin{enumerate}
		\item Меню выбора алгоритма (главное меню, позволяющее выбрать алгоритм)
		\item Обучающий модуль (предоставление основной информации по теме)
		\item Тестирующий модуль (тестирование пользователя по данной теме)	
	\end{enumerate}
	
	Програмный пакет имеет следующую структуру:
	\begin{itemize}
		\item { AlgoTeacher.Forms --- Формы:
			\begin{itemize}
				\item MainForm--- Главная форма; 
				\item InformationForm --- Информационная форма, описывающая алгоритм;
				\item IntroForm --- Вступительная форма для соответствующего модуля;
				\item LanguageForm --- Форма выбора языка.
			\end{itemize}
		}
		\item { AlgoTeacher.Events --- События:
			\begin{itemize}
				\item QuestEvents --- Событие задачи вопроса пользователю
				\item FillEvents --- Событие заполнение данных на форме
			\end{itemize}
		}
		\item { AlgoTeacher.Controls --- Пользовательские элементы управления:
			\begin{itemize}
				\item MatrixGridView --- Модифицированый GridControl для работы с матрицами;
				\item RotatingLabel --- Модифицированый LabelControl с возможностью поворачивать текст;
				\item RotatingLabelControlPainter --- Вспомогательный класс для отрисовки поворачиваемого label'a;
				\item QuestionControlBase --- Базовая форма для ввода ответа;
				\item StringQuestionControl --- Форма для ввода ответа в виде строки;
				\item TwoStringQuestionControl --- Форма для ввода ответа в виде двух строк (например количество строк-столбцов);
				\item ThreeStringQuestionControl --- Форма для ввода ответа в виде трёх строк (например координаты и значение);
				\item TwoVariantsQuestionControl --- Форма для ввода ответа вида "да/нет".
			\end{itemize}
		}
		\item { AlgoTeacher.Modules --- Модули с алгоритмами решения конкретных задачь:
			\begin{itemize}
				\item MatrixMultiplyForm --- Форма алгоритма перемножения матриц;
				\item KnapsackProblemForm --- Форма алгоритма задачи о рюкзаке;
				\item TransportTaskForm --- Форма алгоритма транспортной задачи;
				\item MatrixMultiply --- Алгоритм перемножения матриц;
				\item KnapsackProblem --- Алгоритм задачи о рюкзаке;
				\item TransportTask --- Алгоритм транспортной задачи;		
			\end{itemize}
		}
		\item { AlgoTeacher.Model --- Модели:
			\begin{itemize}
				\item Coordinate --- Класс представления и работы с координатами;
				\item Matrix --- Класс представления и работы с матрицей;
				\item Task --- Класс представления и работы с алгоритмом;
				\item TaskHelp --- Класс представления и работы с подсказками;
				\item Information --- Класс представления и работы с информацией по алгоритму.
			\end{itemize}
		}
		\item { AlgoTeacher.Interfaces --- Интерфейсы:
			\begin{itemize}
				\item IQuest --- Интерфейс классов для вопросов
			\end{itemize}
		}
		\item { AlgoTeacher.Quests --- Виды вопросов:
			\begin{itemize}
				\item DoubleValueQuest --- Вопрос с числом с плавающей точкой;
				\item IntegerIntegerValueQuest --- Вопрос с двумя целыми числами;
				\item IntegerValueQuest --- Вопрос с целым числом;
				\item StringQuest --- Вопрос со строкой;
				\item YesNoQuest --- Вопрос вида "да/нет";
				\item RangeQuest --- Вопрос с диапозоном значений.
			\end{itemize}
		}
	\end{itemize}
	
	Ниже рассмотрим некоторые элементы подробнее.	
	
	Главное меню (MainForm) является основной формой приложения, в данную форму можно вернуться из запущенных модулей и отсюда начинается путешествие по обучающей программе.  
	Список на форме содержит набор реализованных модулей, основанных на объекте Task. Про Модули будет подробнее написано ниже.
	Для добавления нового модуля нужно создать модуль (см. пункт Модули), а затем добавить их к списку, всё остальное программа будет делать сама. Выбрав алгоритм и нажав кнопку на форме, пользователь перейдёт непосредственно к обучению соответствующему алгоритму. 

	В программе предусмотрено использование разных языков (необходимо лишь добавлять соответствующие варианты текста). При этом новые текстовые данные будет загружены из локальной базы данных, либо из соответствующего текстового файла.

	$IntroForm$ является своеобразным приветствием и предоставляет пользователю выбор: пройти обучение или сразу перейти к практическому заданию.
	
	$InformationForm$ предоставляет пользователю информацию по данному алгоритму. 
	Для изучения доступно 3 уровня подсказок:

	\begin{enumerate}
		\item Основная информация
		\item Подробная информация
		\item Разбор примера
	\end{enumerate}
	В случае успешного усвоения информации можно перейти к прохождению теста.  \\
	
	На данном этапе мы переходим к форме, связанной с конкретным обучающим модулем. Данные для алгоритма генерируются случайным образом. \\
	
	Тест заключается в вопросах 2-х уровней сложности: 
	\begin{enumerate}
		\item Вопрос на выполнимость алгоритма
		\item Группа вопросов по мере выполнения алгоритма
	\end{enumerate}
	
	По сути, уровни вопросов - это шаги алгоритма.
	
	Если пользователь неправильно отвечает на заданные вопросы, то ему выводится поясняющая информация, например выделяет нужные строки-столбцы матриц, выводит формулы и т.д. Если же пользователь совершает ошибки слишком часто, то программа предлагает пользователю вернуться в главное меню. Там он может либо выбрать другой алгоритм, либо заново пройти обучение.
	
	При последовательных правильных ответах программа начинает задавать вопросы следующего уровня, пока не удостоверится, что пользователь со всем справился. \\
	
	При расширении программы можно добавлять новые виды заданий. Для этого нужно использовать интерфейс IQuest и добавлять нужные контролы на основе реализованного задания. \\
	
	Ниже будут подробнее разобраны сами модули, как их создавать и использовать, а также будет подробнее описаны логические компоненты программы.
	
	\subsection{Модули}

	Модулем в нашем случае является набор классов, созданных для конкретного алгоритма.
	
	Модуль содержит в себе обучающую и тестирующую Функциональность. Модуль состоит из модифицированного алгоритма решения конкретной задачи и формы. 
	
	Алгоритм должен быть разбит на отдельные фукнции, выполняющие какую-то логически завершённую часть алгоритма.
	
	Основой модуля объект Task, включающий в себя:
	\begin{itemize}
		\item Name - имя модуля
		\item \_formType - тип формы для отображения тестирования алгоритма
		\item \_introText - приветствие и общая информация по данному алгоритму, используется в IntroForm
		\item \_help - экземпляр класса TaskHelp, собственно обучающая часть программы
	\end{itemize}
	
	Для добавления нового модуля необходимо выполнить следующие действия: 
	\begin{itemize}
		\item Добавить вводную информацию/приветствие;
		\item Создать необходимый TaskHelp с обучающей информацией по данному алгоритму;
		\item Если нужно, то добавить собственные виды вопросов, при этом нужно реализовать IQuest и создать соответствующий элемент управления;
		\item Добавьте форму для тестирования вашего алгоритма, в обработчике которой выделите уровни вопросов. Форма создаётся на основе примеров. Для вопросов используйте имеющиеся Quest классы. Для создания формы можно использовать подготовленные пользовательские элементы управления;
		\item Добавьте класс с алгоритмом, в котором используйте QuestEvent и FillEvent для взаимодействия с пользователем;
		\item Создайте экземпляр класса с алгоритмом в форме и добавте нужные вызовы функций. В случае работы с циклами используйте отдельный поток;
		\item Добавте обработчики QuestEvent и FillEvent;
		\item Создаёте Task и добавьте его в список модулей на главной форме.
	\end{itemize}
	
	Task имеет несколько основный методов: 
	\begin{itemize}
		\item ShowIntro() --- открывает вступительную форму
		\item ShowInfo() --- открывает обучающую форму с прекреплённой информацией
		\item ShowTest() --- открывает тестирующую форму
	\end{itemize}
	
	При реализации IQuest нужно реализовать представление имени вопроса, сам текст вопроса и правильный ответ, а также реализовать функцию проверки ответа.
	
	Для взаимодействия с пользователем нужно использовать событие questEvent(). 
	Аргументом questEvent является QuestEventArgs(IQuest quest, Coordinate coord), при этом Coorditane --- это класс координат вопроса, позволяющий указывать, на какую часть теста он ссылается. тест. 
	
	Для удобства разработки можно использовать приложенные шаблоны модулей с примерами.
	
	Далее приводится пример модуля на основе алгоритма перемножения матриц.
	
	\section{Обучение алгоритмам средствами пакета прикладных программ}
	\subsection{Алгоритм перемножения матриц}
	Рассмотрим работу нашей системы на алгоритме перемножения матриц.
	
	В начале появляется окно выбора языка. Выбираем язык и переходим в главное меню.

	Для того, чтобы начать обучение данному алгоритму, в главном меню в списке задач нужно выбрать задачу "Умножение матриц" (см. рис. 2).
	
	\begin{center}
	\includegraphics[width=13cm]{choose_algo.png}

	Рисунок $2$ --- Выбор задачи.
	\end{center}
	
	После того, как будет нажата кнопка "Старт", произойдет переход на другую форму --- форму приветствия, где обучающая система узнает о ваших желаниях по поводу обучения данному алгоритму (см. рис. 3).
	
	\begin{center}
	\includegraphics[width=13cm]{hello.png}

	Рисунок $3$ --- Форма приветствия.
	\end{center}

	Если вы нажимаете на кнопку "Я всё умею", то будете "переброшены" на форму перемножения матриц, где и начнете проходить тесты для подтверждения ваших знаний, но об этом попозже.
	Если же вы только хотите овладеть данным алгоритмом, то выбираете кнопку "Да, конечно!", после нажатия на которую вы перейдёте на форму с информацией о алгоритме перемножения матриц (см. рис. 4).
	
	\begin{center}
	\includegraphics[width=13cm]{explain_1.png}

	Рисунок $4$ --- Начальное обучение задаче.
	\end{center}
	
	Если вам будет не достаточно этого определения, то вы сможете получить об этом алгоритме дополнительную информацию, нажав на кнопку "Не понял, расскажи подробнее".
	Тогда на форме будет предложен другой текст, но уже с более подробной информацией.
	Если же и этого будет не достаточно для понимая данного алгоритма, то вам будет предложено пройти обучение заново.
	Однако, если вам удалось овладеть данным материалом, то у вас будет возможность перейти к тестам, нажав на кнопку "Давай решать задачи".
	Переходим на форму перемножения матриц, где нам предложены две матриц и задается вопрос --- можно ли их перемножить (см. рис. 5)?
	
	\begin{center}
	\includegraphics[width=13cm]{matrix_multiply.png}

	Рисунок $5$ --- Уровень 1.
	\end{center}

	Если мы отвечаем неправильно, то нам будет предложен тот же самый вопрос, но уже с другими матрицами.
	Но, ответив правильно, мы переходим на второй уровень, где нам опять предложены две матрицы, но в качестве ответа требуется размерность матрицы, которая получится в результате перемножения данных двух (см. рис. 6).
	
	\begin{center}

	\includegraphics[width=12cm]{stage_2.png}

	Рисунок $6$ --- Уровень 2.
	\end{center}

	Правильно ответив на вопрос 2-го уровня (см. рис. 7), мы переходим на третий уровень.
	
	\begin{center}
	\includegraphics[width=12cm]{stage_2_right.png}

	Рисунок $7$ --- Правильный ответ на вопрос 2-го уровня.
	\end{center}


	На третем уровне программа будет выборочно спрашивать о результате перемножения для каких-нибудь случайно выбранных элементав результирующей матрицы (см. рис. 8). Остальные элементы программа заполнит сама.
	
	\begin{center}
	\includegraphics[width=12cm]{stage_3_1.png}

	Рисунок $8$ --- Вопрос 3-го уровня.
	\end{center}
	
	В процессе, если пользователь отвечает не правильно, программа ему подсказывает. Сначала выделяет строку и столбец, которые используются для вычисления текущего элемента(см. рис. 9). 
	
	\begin{center}
	\includegraphics[width=12cm]{stage_3_2.png}

	Рисунок $9$ --- Пример подсказки 1-го уровня.
	\end{center}
	
	Если и после этого пользователь неправильно отвечает, то выводится формула перемножения (см. рис. 10). 
	
	\begin{center}
	\includegraphics[width=12cm]{stage_3_3.png}

	Рисунок $10$ ---  Пример подсказки 2-го уровня.
	\end{center}
	
	На третий неправильный ответ, программа подставляет в формулу данные из матриц (см. рис. 11) и если после этого пользователь не может правильно ответить, программа предлагает пройти обучение ещё раз.
	
	\begin{center}
	\includegraphics[width=12cm]{stage_3_4.png}

	Рисунок $11$ ---  Пример подсказки 3-го уровня.
	\end{center}
	
	По окончанию теста программа хвалит пользователя за успешное прохождение (см. рис. 12).

	\begin{center}
	\includegraphics[width=12cm]{stage_3_res.png}

	Рисунок $12$ ---  Завершение теста.
	\end{center}
	